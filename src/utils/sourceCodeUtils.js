'use strict';

const path = require('path');
const { createOkResult, createErrorResult, getResultData } = require('../result');
const { toPascalCase, toCamelCase, toWords } = require('./stringUtils');

const emptyLine = '';
const newLine = '\r\n';

const createIndentation = (level) => {
    let indentation = '';
    const indentation1 = '    ';
    for (let i = 0; i < level; i++) {
        indentation += indentation1;
    }
    return indentation;
};

const createJSDocDescription = (indetation, data) => {
    const { description, params, returns } = data;
    const lines = [];
    lines.push(`${indetation}/**`);

    if (Array.isArray(description)) {
        description.forEach(line => lines.push(`${indetation} * ${line}`));
    } else {
        lines.push(`${indetation} * ${description}`);
    }

    if (params && params.length && params.length > 0) {
        lines.push(`${indetation} *`);
        params.forEach(param => {
            const { type, name, description } = param;
            lines.push(`${indetation} * @param {${type}} ${name} ${description}`);
        });
    }

    if (returns) {
        const { type: returnType, description: returnDescription } = returns;
        lines.push(`${indetation} *`);
        lines.push(`${indetation} * @returns {${returnType}} ${returnDescription}`);
    }

    lines.push(`${indetation} */`);
    return lines;
};

const createPropName = (name) => toCamelCase(name);
const createSetPropName = (name) => `set${toPascalCase(name)}`;    
const createGetPropName = (name) => `get${toPascalCase(name)}`;    
const createStatePropName = (name) => `${toCamelCase(name)}State`;    
const createSetStatePropName = (name) => `set${toPascalCase(name)}State`;    
const createSetEventHandlerPropName = (name) => `${toCamelCase(name)}SetEventHandler`;   
const createUrlParamPropName = (name) => `${toCamelCase(name)}UrlParam`;   
const createWithPropName = (name) => `with${toPascalCase(name)}`;   

const createProp = (name, typeOrValue, isOptional, canBeUndefined) => 
    `${name}${isOptional ? '?' : ''}: ${canBeUndefined ? `undefined | ${typeOrValue}` : typeOrValue }`;

const createHeader = (sourceCodeGeneratorInfo, imports) => {
    const { name: generatorName, version: generatorVersion, time } = sourceCodeGeneratorInfo;
    const lines = [];
    lines.push(`// Generated by ${generatorName}@${generatorVersion} on ${time}.`);
    lines.push('// Do not edit this file manually unless you disabled its code generation.');
    imports.forEach(x => lines.push(x));
    return lines;
};

const createContextHeader = ({ sourceCodeGeneratorInfo }) => {
    const imports = [`import React from 'react';`];
    const header = createHeader(sourceCodeGeneratorInfo, imports);
    return header;
};

const createStatePropsInterfaceName = (name) => `I${toPascalCase(name)}StateProps`;

const createStatePropsInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} state props interface.` });
    const interfaceName = createStatePropsInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${createIndentation(1)}${createProp(createPropName(name), type, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createStateInterfaceName = (name) => `I${toPascalCase(name)}State`;

const createStateInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} state interface.` });
    const interfaceName = createStateInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${createIndentation(1)}${createProp(createStatePropName(name), type)};`);
        lines.push(`${createIndentation(1)}${createProp(createSetStatePropName(name), `React.Dispatch<React.SetStateAction<${type}>>`, false, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createContextProviderPropsInterfaceName = (name) => `I${toPascalCase(name)}ContextProviderProps`;

const createContextProviderPropsInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} context provider props interface.` });
    const interfaceName = createContextProviderPropsInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    lines.push(`${createIndentation(1)}${createProp('children', 'React.ReactNode')};`);
    lines.push(`${createIndentation(1)}${createProp(createStatePropName(name), createStateInterfaceName(name))};`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${createIndentation(1)}${createProp(createSetEventHandlerPropName(name), `(${name}: ${type}) => void`, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createContextValueInterfaceName = (name) => `I${toPascalCase(name)}ContextValue`;

const createContextValueInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} context value interface.` });
    const interfaceName = createContextValueInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${createIndentation(1)}${createProp(createPropName(name), type)};`);
        lines.push(`${createIndentation(1)}${createProp(createSetPropName(name), `(${name}: ${type}) => void;`)}`);
    });
    lines.push('};');
    return lines;
};

const createDefaultValueName = (name) => `Default${toPascalCase(name)}`;

const createValue = (value, type) => {
    if (type === 'string') {
        return `'${value}'`;
    }

    return value;
};

const createDefaultValues = ({ typeDef }) => {
    const { props } = typeDef;
    const lines = props.map(p => {
        const { name, type, defaultValue } = p;
        return `export const ${createDefaultValueName(name)} = ${createValue(defaultValue, type)};`;
    });
    return lines;
};

const createDefaultStateName = (name) => `Default${toPascalCase(name)}State`;

const createDefaultState = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The default ${toPascalCase(name)} state.` });
    const interfaceName = createStateInterfaceName(name);
    const typeName = createDefaultStateName(name);
    lines.push(`export const ${typeName}: ${interfaceName} = {`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(1)}${createProp(createStatePropName(name), createDefaultValueName(name))},`);
        lines.push(`${createIndentation(1)}${createProp(createSetStatePropName(name), 'undefined')},`);
    });
    lines.push('};');
    return lines;
};

const createDefaultContextValueName = (name) => `Default${toPascalCase(name)}ContextValue`;

const createDefaultContextValue = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The default ${toPascalCase(name)} context value.` });
    const interfaceName = createContextValueInterfaceName(name);
    const typeName = createDefaultContextValueName(name);
    lines.push(`export const ${typeName}: ${interfaceName} = {`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${createIndentation(1)}${createProp(createPropName(name), createDefaultValueName(name))},`);
        lines.push(`${createIndentation(1)}${createProp(createSetPropName(name), `(${name}: ${type}) => {},`)}`);
    });
    lines.push('};');
    return lines;
};

const createStateName = (name) => `${toPascalCase(name)}State`;

const createState = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} state.` });
    const interfaceName = createStatePropsInterfaceName(name);
    const typeName = createStateName(name);
    lines.push(`export const ${typeName} = ({`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(3)}${createPropName(name)},`);
    });
    lines.push(`${createIndentation(2)}}: ${interfaceName}) => {`);
    lines.push(emptyLine);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${createIndentation(1)}const [ ${createStatePropName(name)}, ${createSetStatePropName(name)} ] = React.useState<${type}>(${createPropName(name)} || ${createDefaultValueName(name)});`);
    });
    lines.push(emptyLine);
    lines.push(`${createIndentation(1)}const ${createStatePropName(name)} = {`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(2)}${createStatePropName(name)},`);
        lines.push(`${createIndentation(2)}${createSetStatePropName(name)},`);
    });
    lines.push(`${createIndentation(1)}};`);
    lines.push(emptyLine);
    lines.push(`${createIndentation(1)}return ${createStatePropName(name)}`);
    lines.push('};');
    return lines;
};

 const createContextName = (name) => `${toPascalCase(name)}Context`;

const createContext = ({ typeDef }) => {
    const { name } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} context.` });
    const interfaceName = createContextValueInterfaceName(name);
    const typeName = createContextName(name);
    const defaultValueName = createDefaultContextValueName(name);
    lines.push(`export const ${typeName} = React.createContext<${interfaceName}>(${defaultValueName});`);
    return lines;
};

const createContextProviderName = (name) => `${toPascalCase(name)}ContextProvider`;

const createContextProvider = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} context provider.` });
    const typeName = createContextProviderName(name);
    lines.push(`export const ${typeName} = ({`);
    lines.push(`${createIndentation(3)}children,`);
    lines.push(`${createIndentation(3)}${createStatePropName(name)},`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(3)}${createSetEventHandlerPropName(name)},`);
    });
    lines.push(`${createIndentation(2)}}: ${createContextProviderPropsInterfaceName(name)}) => {`);
    lines.push(emptyLine);
    lines.push(`${createIndentation(1)}const {`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(2)}${createStatePropName(name)},`);
        lines.push(`${createIndentation(2)}${createSetStatePropName(name)},`);
    });
    lines.push(`${createIndentation(1)}} = ${createStatePropName(name)} || {};`);
    lines.push(emptyLine);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(1)}React.useEffect(() => {`);
        lines.push(`${createIndentation(2)}${createSetEventHandlerPropName(name)} && ${createSetEventHandlerPropName(name)}(${createStatePropName(name)});`);
        lines.push(`${createIndentation(1)}}, [ ${createStatePropName(name)}, ${createSetStatePropName(name)}, ${createSetEventHandlerPropName(name)} ]);`);
        lines.push(emptyLine);
    });
    lines.push(`${createIndentation(1)}const contextValue: ${createContextValueInterfaceName(name)} = {`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${createIndentation(2)}${createProp(createPropName(name), createStatePropName(name))},`);
        lines.push(`${createIndentation(2)}${createProp(createSetPropName(name), `(${name}: ${type}) => ${createSetStatePropName(name)} && ${createSetStatePropName(name)}(${createPropName(name)}),`)}`);
    });
    lines.push(`${createIndentation(1)}};`);
    lines.push(emptyLine);
    lines.push(`${createIndentation(1)}return (`);
    lines.push(`${createIndentation(2)}<${createContextName(name)}.Provider value={contextValue}>`);
    lines.push(`${createIndentation(3)}{children}`);
    lines.push(`${createIndentation(2)}</${createContextName(name)}.Provider>`);
    lines.push(`${createIndentation(1)});`);
    lines.push(`};`);
    return lines;
};

const createContextFileContent = (typeDef, sourceCodeGeneratorInfo) => {
    const lines = [
        createContextHeader,
        createStatePropsInterface,
        createStateInterface,
        createContextProviderPropsInterface,
        createContextValueInterface,
        createDefaultValues,
        createDefaultState,
        createDefaultContextValue,
        createState,
        createContext,
        createContextProvider
    ]
    .map(x => x({ sourceCodeGeneratorInfo, typeDef }))
    .reduce((acc, currentValue) => 
        acc = acc.concat(currentValue).concat([emptyLine]), []);

    const content = lines.join(newLine);
    return content;
};

const createContextFileName = (name) => `${toCamelCase(name)}Context.ts`;

const contextBuilderUtilsContent = `
import React from 'react';
import { createHashHistory } from 'history';

const createKey = () => Math.random().toString(36).substr(2, 5);

const createChild = (type: () => JSX.Element) => React.createElement(type);

const createChildWithKey = (type: () => JSX.Element) => React.createElement(type, { key: createKey() });

export const createChildren = (content: (() => JSX.Element) | (Array<() => JSX.Element>)) => {
    let children: React.ReactNode;
    
    if (Array.isArray(content)) {
        children = (content as Array<() => JSX.Element>).map(createChildWithKey)
    } else {
        children = createChild(content as () => JSX.Element);
    }

    return children;
};

const history = createHashHistory();

export const getHistory = () => history;

export const deserializePathname = (pathname: string) => {
    const normalizedPathname = (pathname ? (pathname[0] === '/' ? pathname.substr(1) : pathname) : '');
    const deserializedPathname = normalizedPathname.length
        ? normalizedPathname
            .split('&')
            .reduce((acc, kv) => {
                const [key, value] = kv.split('=');
                acc[key] = value;
                return acc;
            }, {} as any)
        : {};
    return deserializedPathname;
};

export const serializePathname = (pathname: any) =>
    Object.keys(pathname)
        .map(key => ` + '`' + '${key}=${pathname[key]}' + '`' + `)
        .sort()
        .join('&');
`;

const contextBuilderUtilFile = { name: 'contextBuilderUtils.ts', content: contextBuilderUtilsContent };

const createContextBuilderHeader = ({ sourceCodeGeneratorInfo, typeDef }) => {
    const { name } = typeDef;

    const contextImports = [
        createContextProviderName,
        createStateInterfaceName,
        createStateName,
        createDefaultStateName
    ]
    .map(x => x(name))
    .join(', ');

    const contextFileName = path.parse(createContextFileName(name)).name;
    const contextBuilderUtilsFileName = path.parse(contextBuilderUtilFile.name).name;

    const imports = [
        `import React from 'react';`,
        `import ReactDOM from 'react-dom';`,
        `import { Router, Route, useHistory } from 'react-router-dom';`,
        `import { History, Location } from 'history';`,
        `import { ${contextImports} } from './${contextFileName}';`,
        `import { createChildren, getHistory, deserializePathname, serializePathname } from './${contextBuilderUtilsFileName}';`
    ];
    const header = createHeader(sourceCodeGeneratorInfo, imports);
    return header;
};

const createContextInterfaceName = (name) => `I${toPascalCase(name)}Context`;

const createContextInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), { description: `The ${toPascalCase(name)} context interface.` });
    const interfaceName = createContextInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    
    createJSDocDescription(createIndentation(1), { description: 'The component to be rendered.' })
    .forEach(line => lines.push(line));
    
    lines.push(`${createIndentation(1)}${createProp('Component', '() => JSX.Element')};`);
    lines.push(emptyLine);

    createJSDocDescription(createIndentation(1), {
        description: 'Renderes the component.', 
        params: [
            { type: 'Element | DocumentFragment | null', name: 'container', description: 'The container. Optional parameter.' }
        ]})
    .forEach(line => lines.push(line));

    lines.push(`${createIndentation(1)}${createProp('render', '(container: Element | DocumentFragment | null) => void')};`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(emptyLine);

        createJSDocDescription(createIndentation(1), { description: `Gets the ${createPropName(name)}.` })
        .forEach(line => lines.push(line));

        lines.push(`${createIndentation(1)}${createProp(createGetPropName(name), `() => ${type}`)};`);
        lines.push(emptyLine);
        
        createJSDocDescription(createIndentation(1), { description: `Sets the ${createPropName(name)}.` })
        .forEach(line => lines.push(line));

        lines.push(`${createIndentation(1)}${createProp(createSetPropName(name), `(${createPropName(name)}: ${type}) => void;`)}`);
    });
    lines.push('};');
    return lines;
};

const componentPropsInterfaceName = 'IComponentProps ';

const createComponentPropsInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    lines.push(`export interface ${componentPropsInterfaceName} {`);
    lines.push(`${createIndentation(1)}${createProp('children', 'React.ReactNode')};`);
    lines.push(`${createIndentation(1)}${createProp(createStatePropName(name), createStateInterfaceName(name))};`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${createIndentation(1)}${createProp(createPropName(name), `${type}`, isOptional)};`);
        lines.push(`${createIndentation(1)}${createProp(createUrlParamPropName(name), 'string', isOptional)};`);
        lines.push(`${createIndentation(1)}${createProp(createSetEventHandlerPropName(name), `(${name}: ${type}) => void`, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createContextBuilderName = (name) => `${toPascalCase(name)}ContextBuilder`;

const createContextBuilderPropsVariable = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    lines.push(`${createIndentation(1)}private props: ${componentPropsInterfaceName} = {`);
    lines.push(`${createIndentation(2)}${createProp('children', 'undefined')},`);
    lines.push(`${createIndentation(2)}${createProp(createStatePropName(name), createDefaultStateName(name))},`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${createIndentation(2)}${createProp(createPropName(name), 'undefined')},`);
        lines.push(`${createIndentation(2)}${createProp(createUrlParamPropName(name), 'undefined')},`);
        lines.push(`${createIndentation(2)}${createProp(createSetEventHandlerPropName(name), 'undefined')},`);
    });
    lines.push(`${createIndentation(1)}};`);
    return lines;
};

/*
const createContextBuilderComponent = () => {
    const lines = [];
    lines.push(`${createIndentation(1)}const Component = () => (`);
    lines.push(`${createIndentation(2)}<Router history={getHistory()}>`);
    lines.push(`${createIndentation(3)}<Route>`);
    lines.push(`${createIndentation(4)}<RouteComponent />`);
    lines.push(`${createIndentation(3)}</Route>`);
    lines.push(`${createIndentation(2)}</Router>`);
    lines.push(`${createIndentation(1)});`);
    return lines;
};

const createContextBuilderRender = () => {
    const lines = [];
    lines.push(`${createIndentation(1)}const render = (container: Element | DocumentFragment | null) =>`);
    lines.push(`${createIndentation(2)}ReactDOM.render(`);
    lines.push(`${createIndentation(3)}<React.StrictMode>`);
    lines.push(`${createIndentation(4)}<Component />`);
    lines.push(`${createIndentation(3)}</React.StrictMode>,`);
    lines.push(`${createIndentation(3)}container || document.createElement('div')`);
    lines.push(`${createIndentation(2)});`);
    return lines;
};

const createContextBuilderPropGetter = ({ typeDef, prop }) => {
    const { name: typeName } = typeDef;
    const { name: propName } = prop;
    const lines = [];
    lines.push(`${createIndentation(1)}const ${createGetPropName(propName)} = () => {`);
    lines.push(`${createIndentation(2)}const { ${createStatePropName(propName)} } = this.props.${createStatePropName(typeName)} || {};`);
    lines.push(`${createIndentation(2)}return ${createStatePropName(propName)};`);
    lines.push(`${createIndentation(1)}};`);
    return lines;
};

const createContextBuilderPropSetter = ({ typeDef, prop }) => {
    const { name: typeName } = typeDef;
    const { name: propName, type: propType } = prop;
    const lines = [];
    lines.push(`${createIndentation(1)}const ${createSetPropName(propName)} = (${createPropName(propName)}: ${propType}) => {`);
    lines.push(`${createIndentation(2)}const { ${createSetStatePropName(propName)} } = this.props.${createStatePropName(typeName)} || {};`);
    lines.push(`${createIndentation(2)}${createSetStatePropName(propName)} && ${createSetStatePropName(propName)}(${createPropName(propName)});`);
    lines.push(`${createIndentation(1)}};`);
    return lines;
};

const createContextBuilderProps = ({ typeDef }) => {
    const { props } = typeDef;

    const lines = props.map(prop => [
            createContextBuilderPropGetter,
            createContextBuilderPropSetter
        ]
        .map(x => x({ typeDef, prop }))
        .reduce((acc, currentValue) => 
            acc = acc.concat(currentValue).concat([emptyLine]), []) 
    )
    .reduce((acc, currentValue) => 
            acc = acc.concat(currentValue), []);

    return lines;
};
*/

const createContextBuilderBuild = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createJSDocDescription(createIndentation(1), {
        description: `Builds the ${toPascalCase(name)} Context.`,
        returns: { type: `${createContextInterfaceName(name)}`, description: `The ${toPascalCase(name)} Context Interface.` }
    });
    lines.push(`${createIndentation(1)}build() {`);
    lines.push(`${createIndentation(1)}};`);
    return lines;
};

const createContextBuilderWithProperty = ({ prop, valueFunc }) => {
    const { name, type } = prop;
    const lines = [];
    const value = valueFunc ? `${valueFunc}(${createPropName(name)})` : createPropName(name);
    lines.push(`${createIndentation(1)}${createWithPropName(name)}(${createPropName(name)}: ${type}) {`);
    lines.push(`${createIndentation(2)}this.props.${createPropName(name)} = ${value};`)
    lines.push(`${createIndentation(2)}return this;`)
    lines.push(`${createIndentation(1)}}`);
    return lines;
};

const createContextBuilderWithProperties = ({ typeDef }) => {
    const { props } = typeDef;
    const lines = [];
    const childrenPropName = 'children';
    const childrenPropType = '(() => JSX.Element) | (Array<() => JSX.Element>)';

    createJSDocDescription(createIndentation(1), { 
        description: [
            `Sets the ${childrenPropName}.`,
            `All the children within the context will have the same state.`
        ],
        params: [
            { type: childrenPropType, name: childrenPropName, description: `The ${childrenPropName}.` }
        ]
    })
    .forEach(line => lines.push(line));

    createContextBuilderWithProperty({ 
        prop: { name: childrenPropName, type: childrenPropType }, 
        valueFunc: 'createChildren' 
    })
    .forEach(line => lines.push(line));

    props.map(p => {
        const { name, type, defaultValue } = p;
        return [
            { ...p, description: `. Default value: ${createValue(defaultValue, type)}` },
            { name: createUrlParamPropName(name), type: 'string', description: ` to be synchronized with the ${createPropName(name)} state` },
            { name: createSetEventHandlerPropName(name), type: `(${createPropName(name)}: ${type}) => void` }
        ];
    })
    .reduce((acc, currentValue) => acc = acc.concat(currentValue), [])
    .forEach(p => {
        const { name, type, description = '' } = p;
        lines.push(emptyLine);

        createJSDocDescription(createIndentation(1), { 
            description: `Sets the ${toWords(createPropName(name))}${description}.`,
            params: [
                { type, name, description: `The ${toWords(name)}.` }
            ]
        })
        .forEach(line => lines.push(line));

        createContextBuilderWithProperty({ prop: p })
        .forEach(line => lines.push(line));
    });

    return lines;
};

const createContextBuilder = ({ typeDef }) => {
    const { name } = typeDef;
    const lines = createJSDocDescription(createIndentation(0), {
        description: [
            `The ${toPascalCase(name)} context builder.`,
            `Helps to build the ${toPascalCase(name)} context and manage its state.`
        ]
    });
    const className = createContextBuilderName(name);
    lines.push(`export class ${className} {`);

    [
        createContextBuilderPropsVariable,
        createContextBuilderBuild,
        createContextBuilderWithProperties
    ]
    .map(x => x({ typeDef }))
    .reduce((acc, currentValue, i) => {
        i > 0 && (acc = acc.concat([emptyLine]));
        acc = acc.concat(currentValue);
        return acc;
    }, [])
    .forEach(line => lines.push(line));

    lines.push('};');

    lines.push(emptyLine);
    lines.push(`export default ${createContextBuilderName(name)};`);

    return lines;
};

const createContextBuilderFileContent = (typeDef, sourceCodeGeneratorInfo) => {
    const lines = [
        createContextBuilderHeader,
        createContextInterface,
        createComponentPropsInterface,
        createContextBuilder
    ]
    .map(x => x({ sourceCodeGeneratorInfo, typeDef }))
    .reduce((acc, currentValue) => 
        acc = acc.concat(currentValue).concat([emptyLine]), []);

    const content = lines.join(newLine);
    return content;
};

const createContextFiles = (result, sourceCodeGeneratorInfo) => {
    const { srcData } = getResultData(result);
    const { types } = srcData;

    const files = types
        .map(t => {
            const { name } = t;
            const content = createContextFileContent(t, sourceCodeGeneratorInfo);
            const file = { name: createContextFileName(name), content };
            return file;
        });

    return files;
};

const createContextBuilderFileName = (name) => `${toCamelCase(name)}ContextBuilder.tsx`;

const createContextBuilderFiles = (result, sourceCodeGeneratorInfo) => {
    const { srcData } = getResultData(result);
    const { types } = srcData;

    const files = types
        .filter(t => !t.disableContextBuilder)
        .map(t => {
            const { name } = t;
            const content = createContextBuilderFileContent(t, sourceCodeGeneratorInfo);
            const file = { name: createContextBuilderFileName(name), content };
            return file;
        });

    return files;
};

const createSourceCodes = (result, sourceCodeGeneratorInfo) => 
    new Promise((resolve, reject) => { 
        try {
            const contextFiles = createContextFiles(result, sourceCodeGeneratorInfo);
            const contextBuilderFiles = createContextBuilderFiles(result, sourceCodeGeneratorInfo);
            const utilsFiles = contextBuilderFiles.length > 0 ? [contextBuilderUtilFile] : [];
            const files = contextFiles.concat(contextBuilderFiles).concat(utilsFiles);
            resolve(createOkResult({ files }));
        } catch (err) {
            reject(createErrorResult({ errors: [err] }));
        }
});

module.exports = {
    createSourceCodes
};