'use strict';

const path = require('path');
const { createOkResult, createErrorResult, getResultData } = require('../result');
const { toPascalCase, toCamelCase } = require('./stringUtils');

const emptyLine = '';
const newLine = '\r\n';

const createTypeDocumentation = (description) => {
    const lines = [];
    lines.push('/**');
    if (Array.isArray(description)) {
        description.forEach(line => lines.push(` * ${line}`));
    } else {
        lines.push(` * ${description}`);
    }
    lines.push(' */');
    return lines;
};

const createPropDocumentation = (indetation, description, params) => {
    const lines = [];
    lines.push(`${indetation}/**`);
    lines.push(`${indetation} * ${description}`);

    if (params && params.length && params.length > 0) {
        lines.push(`${indetation} *`);
        params.forEach(param => {
            const { type, name, description } = param;
            lines.push(`${indetation} * @param {${type}} ${name} ${description}`);
        });
    }

    lines.push(`${indetation} */`);
    return lines;
};

const createPropName = (name) => toCamelCase(name);
const createSetPropName = (name) => `set${toPascalCase(name)}`;    
const createGetPropName = (name) => `get${toPascalCase(name)}`;    
const createStatePropName = (name) => `${toCamelCase(name)}State`;    
const createSetStatePropName = (name) => `set${toPascalCase(name)}State`;    
const createSetEventHandlerPropName = (name) => `${toCamelCase(name)}SetEventHandler`;   
const createUrlParamPropName = (name) => `${toCamelCase(name)}UrlParam`;   

const createProp = (name, typeOrValue, isOptional, canBeUndefined) => 
    `${name}${isOptional ? '?' : ''}: ${canBeUndefined ? `undefined | ${typeOrValue}` : typeOrValue }`;

const indentation1 = '    ';
const indentation2 = indentation1 + indentation1;
const indentation3 = indentation1 + indentation1 + indentation1;
const indentation4 = indentation1 + indentation1 + indentation1 + indentation1;

const createHeader = (sourceCodeGeneratorInfo, imports) => {
    const { name: generatorName, version: generatorVersion, time } = sourceCodeGeneratorInfo;
    const lines = [];
    lines.push(`// Generated by ${generatorName}@${generatorVersion} on ${time}.`);
    lines.push('// Do not edit this file manually unless you disabled its code generation.');
    imports.forEach(x => lines.push(x));
    return lines;
};

const createContextHeader = ({ sourceCodeGeneratorInfo }) => {
    const imports = [`import React from 'react';`];
    const header = createHeader(sourceCodeGeneratorInfo, imports);
    return header;
};

const createStatePropsInterfaceName = (name) => `I${toPascalCase(name)}StateProps`;

const createStatePropsInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} state props interface.`);
    const interfaceName = createStatePropsInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${indentation1}${createProp(createPropName(name), type, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createStateInterfaceName = (name) => `I${toPascalCase(name)}State`;

const createStateInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} state interface.`);
    const interfaceName = createStateInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${indentation1}${createProp(createStatePropName(name), type)};`);
        lines.push(`${indentation1}${createProp(createSetStatePropName(name), `React.Dispatch<React.SetStateAction<${type}>>`, false, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createContextProviderPropsInterfaceName = (name) => `I${toPascalCase(name)}ContextProviderProps`;

const createContextProviderPropsInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} context provider props interface.`);
    const interfaceName = createContextProviderPropsInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    lines.push(`${indentation1}${createProp('children', 'React.ReactNode')};`);
    lines.push(`${indentation1}${createProp(createStatePropName(name), createStateInterfaceName(name))};`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${indentation1}${createProp(createSetEventHandlerPropName(name), `(${name}: ${type}) => void`, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createContextValueInterfaceName = (name) => `I${toPascalCase(name)}ContextValue`;

const createContextValueInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} context value interface.`);
    const interfaceName = createContextValueInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${indentation1}${createProp(createPropName(name), type)};`);
        lines.push(`${indentation1}${createProp(createSetPropName(name), `(${name}: ${type}) => void;`)}`);
    });
    lines.push('};');
    return lines;
};

const createDefaultValueName = (name) => `Default${toPascalCase(name)}`;

const createValue = (value, type) => {
    if (type === 'string') {
        return `'${value}'`;
    }

    return value;
};

const createDefaultValues = ({ typeDef }) => {
    const { props } = typeDef;
    const lines = props.map(p => {
        const { name, type, defaultValue } = p;
        return `export const ${createDefaultValueName(name)} = ${createValue(defaultValue, type)};`;
    });
    return lines;
};

const createDefaultStateName = (name) => `Default${toPascalCase(name)}State`;

const createDefaultState = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The default ${toPascalCase(name)} state.`);
    const interfaceName = createStateInterfaceName(name);
    const typeName = createDefaultStateName(name);
    lines.push(`export const ${typeName}: ${interfaceName} = {`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation1}${createProp(createStatePropName(name), createDefaultValueName(name))},`);
        lines.push(`${indentation1}${createProp(createSetStatePropName(name), 'undefined')},`);
    });
    lines.push('};');
    return lines;
};

const createDefaultContextValueName = (name) => `Default${toPascalCase(name)}ContextValue`;

const createDefaultContextValue = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The default ${toPascalCase(name)} context value.`);
    const interfaceName = createContextValueInterfaceName(name);
    const typeName = createDefaultContextValueName(name);
    lines.push(`export const ${typeName}: ${interfaceName} = {`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${indentation1}${createProp(createPropName(name), createDefaultValueName(name))},`);
        lines.push(`${indentation1}${createProp(createSetPropName(name), `(${name}: ${type}) => {},`)}`);
    });
    lines.push('};');
    return lines;
};

const createStateName = (name) => `${toPascalCase(name)}State`;

const createState = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} state.`);
    const interfaceName = createStatePropsInterfaceName(name);
    const typeName = createStateName(name);
    lines.push(`export const ${typeName} = ({`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation3}${createPropName(name)},`);
    });
    lines.push(`${indentation2}}: ${interfaceName}) => {`);
    lines.push(emptyLine);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${indentation1}const [ ${createStatePropName(name)}, ${createSetStatePropName(name)} ] = React.useState<${type}>(${createPropName(name)} || ${createDefaultValueName(name)});`);
    });
    lines.push(emptyLine);
    lines.push(`${indentation1}const ${createStatePropName(name)} = {`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation2}${createStatePropName(name)},`);
        lines.push(`${indentation2}${createSetStatePropName(name)},`);
    });
    lines.push(`${indentation1}};`);
    lines.push(emptyLine);
    lines.push(`${indentation1}return ${createStatePropName(name)}`);
    lines.push('};');
    return lines;
};

 const createContextName = (name) => `${toPascalCase(name)}Context`;

const createContext = ({ typeDef }) => {
    const { name } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} context.`);
    const interfaceName = createContextValueInterfaceName(name);
    const typeName = createContextName(name);
    const defaultValueName = createDefaultContextValueName(name);
    lines.push(`export const ${typeName} = React.createContext<${interfaceName}>(${defaultValueName});`);
    return lines;
};

const createContextProviderName = (name) => `${toPascalCase(name)}ContextProvider`;

const createContextProvider = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} context provider.`);
    const typeName = createContextProviderName(name);
    lines.push(`export const ${typeName} = ({`);
    lines.push(`${indentation3}children,`);
    lines.push(`${indentation3}${createStatePropName(name)},`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation3}${createSetEventHandlerPropName(name)},`);
    });
    lines.push(`${indentation2}}: ${createContextProviderPropsInterfaceName(name)}) => {`);
    lines.push(emptyLine);
    lines.push(`${indentation1}const {`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation2}${createStatePropName(name)},`);
        lines.push(`${indentation2}${createSetStatePropName(name)},`);
    });
    lines.push(`${indentation1}} = ${createStatePropName(name)} || {};`);
    lines.push(emptyLine);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation1}React.useEffect(() => {`);
        lines.push(`${indentation2}${createSetEventHandlerPropName(name)} && ${createSetEventHandlerPropName(name)}(${createStatePropName(name)});`);
        lines.push(`${indentation1}}, [ ${createStatePropName(name)}, ${createSetStatePropName(name)}, ${createSetEventHandlerPropName(name)} ]);`);
        lines.push(emptyLine);
    });
    lines.push(`${indentation1}const contextValue: ${createContextValueInterfaceName(name)} = {`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(`${indentation2}${createProp(createPropName(name), createStatePropName(name))},`);
        lines.push(`${indentation2}${createProp(createSetPropName(name), `(${name}: ${type}) => ${createSetStatePropName(name)} && ${createSetStatePropName(name)}(${createPropName(name)}),`)}`);
    });
    lines.push(`${indentation1}};`);
    lines.push(emptyLine);
    lines.push(`${indentation1}return (`);
    lines.push(`${indentation2}<${createContextName(name)}.Provider value={contextValue}>`);
    lines.push(`${indentation3}{children}`);
    lines.push(`${indentation2}</${createContextName(name)}.Provider>`);
    lines.push(`${indentation1});`);
    lines.push(`};`);
    return lines;
};

const createContextFileContent = (typeDef, sourceCodeGeneratorInfo) => {
    const lines = [
        createContextHeader,
        createStatePropsInterface,
        createStateInterface,
        createContextProviderPropsInterface,
        createContextValueInterface,
        createDefaultValues,
        createDefaultState,
        createDefaultContextValue,
        createState,
        createContext,
        createContextProvider
    ]
    .map(x => x({ sourceCodeGeneratorInfo, typeDef }))
    .reduce((acc, currentValue) => 
        acc = acc.concat(currentValue).concat([emptyLine]), []);

    const content = lines.join(newLine);
    return content;
};

const createContextFileName = (name) => `${toCamelCase(name)}Context.ts`;

const contextBuilderUtilsContent = `
import React from 'react';
import { createHashHistory } from 'history';

const createKey = () => Math.random().toString(36).substr(2, 5);

const createChild = (type: () => JSX.Element) => React.createElement(type);

const createChildWithKey = (type: () => JSX.Element) => React.createElement(type, { key: createKey() });

export const createChildren = (content: (() => JSX.Element) | (Array<() => JSX.Element>)) => {
    let children: React.ReactNode;
    
    if (Array.isArray(content)) {
        children = (content as Array<() => JSX.Element>).map(createChildWithKey)
    } else {
        children = createChild(content as () => JSX.Element);
    }

    return children;
};

const history = createHashHistory();

export const getHistory = () => history;

export const deserializePathname = (pathname: string) => {
    const normalizedPathname = (pathname ? (pathname[0] === '/' ? pathname.substr(1) : pathname) : '');
    const deserializedPathname = normalizedPathname.length
        ? normalizedPathname
            .split('&')
            .reduce((acc, kv) => {
                const [key, value] = kv.split('=');
                acc[key] = value;
                return acc;
            }, {} as any)
        : {};
    return deserializedPathname;
};

export const serializePathname = (pathname: any) =>
    Object.keys(pathname)
        .map(key => ` + '`' + '${key}=${pathname[key]}' + '`' + `)
        .sort()
        .join('&');
`;

const contextBuilderUtilFile = { name: 'contextBuilderUtils.ts', content: contextBuilderUtilsContent };

const createContextBuilderHeader = ({ sourceCodeGeneratorInfo, typeDef }) => {
    const { name } = typeDef;

    const contextImports = [
        createContextProviderName,
        createStateInterfaceName,
        createStateName,
        createDefaultStateName
    ]
    .map(x => x(name))
    .join(', ');

    const contextFileName = path.parse(createContextFileName(name)).name;
    const contextBuilderUtilsFileName = path.parse(contextBuilderUtilFile.name).name;

    const imports = [
        `import React from 'react';`,
        `import ReactDOM from 'react-dom';`,
        `import { Router, Route, useHistory } from 'react-router-dom';`,
        `import { History, Location } from 'history';`,
        `import { ${contextImports} } from './${contextFileName}';`,
        `import { createChildren, getHistory, deserializePathname, serializePathname } from './${contextBuilderUtilsFileName}';`
    ];
    const header = createHeader(sourceCodeGeneratorInfo, imports);
    return header;
};

const createContextInterfaceName = (name) => `I${toPascalCase(name)}Context`;

const createContextInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = createTypeDocumentation(`The ${toPascalCase(name)} context interface.`);
    const interfaceName = createContextInterfaceName(name);
    lines.push(`export interface ${interfaceName} {`);
    createPropDocumentation(indentation1, 'The component to be rendered.')
        .forEach(line => lines.push(line));
    lines.push(`${indentation1}${createProp('Component', '() => JSX.Element')};`);
    lines.push(emptyLine);
    createPropDocumentation(indentation1, 'Renderes the component.', [
        { type: 'Element | DocumentFragment | null', name: 'container', description: 'The container. Optional parameter.' }
    ])
        .forEach(line => lines.push(line));
    lines.push(`${indentation1}${createProp('render', '(container: Element | DocumentFragment | null) => void')};`);
    props.forEach(p => {
        const { name, type } = p;
        lines.push(emptyLine);
        createPropDocumentation(indentation1, `Gets the ${createPropName(name)}.`)
            .forEach(line => lines.push(line));
        lines.push(`${indentation1}${createProp(createGetPropName(name), `() => ${type}`)};`);
        lines.push(emptyLine);
        createPropDocumentation(indentation1, `Sets the ${createPropName(name)}.`)
            .forEach(line => lines.push(line));
        lines.push(`${indentation1}${createProp(createSetPropName(name), `(${createPropName(name)}: ${type}) => void;`)}`);
    });
    lines.push('};');
    return lines;
};

const componentPropsInterfaceName = 'IComponentProps ';

const createComponentPropsInterface = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    lines.push(`export interface ${componentPropsInterfaceName} {`);
    lines.push(`${indentation1}${createProp('children', 'React.ReactNode')};`);
    lines.push(`${indentation1}${createProp(createStatePropName(name), createStateInterfaceName(name))};`);
    props.forEach(p => {
        const { name, type, isOptional } = p;
        lines.push(`${indentation1}${createProp(createPropName(name), `${type}`, isOptional)};`);
        lines.push(`${indentation1}${createProp(createUrlParamPropName(name), 'string', isOptional)};`);
        lines.push(`${indentation1}${createProp(createSetEventHandlerPropName(name), `(${name}: ${type}) => void`, isOptional)};`);
    });
    lines.push('};');
    return lines;
};

const createContextBuilderName = (name) => `${toPascalCase(name)}ContextBuilder`;

const createContextBuilderPropsVariable = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    lines.push(`${indentation1}private props: ${componentPropsInterfaceName} = {`);
    lines.push(`${indentation2}${createProp('children', 'undefined')},`);
    lines.push(`${indentation2}${createProp(createStatePropName(name), createDefaultStateName(name))},`);
    props.forEach(p => {
        const { name } = p;
        lines.push(`${indentation2}${createProp(createPropName(name), 'undefined')},`);
        lines.push(`${indentation2}${createProp(createUrlParamPropName(name), 'undefined')},`);
        lines.push(`${indentation2}${createProp(createSetEventHandlerPropName(name), 'undefined')},`);
    });
    lines.push(`${indentation1}};`);
    return lines;
};

const createContextBuilderBuild = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    lines.push(`${indentation1}build() {`);
    lines.push(`${indentation1}};`);
    return lines;
};

const createContextBuilderComponent = () => {
    const lines = [];
    lines.push(`${indentation1}const Component = () => (`);
    lines.push(`${indentation2}<Router history={getHistory()}>`);
    lines.push(`${indentation3}<Route>`);
    lines.push(`${indentation4}<RouteComponent />`);
    lines.push(`${indentation3}</Route>`);
    lines.push(`${indentation2}</Router>`);
    lines.push(`${indentation1});`);
    return lines;
};

const createContextBuilderRender = () => {
    const lines = [];
    lines.push(`${indentation1}const render = (container: Element | DocumentFragment | null) =>`);
    lines.push(`${indentation2}ReactDOM.render(`);
    lines.push(`${indentation3}<React.StrictMode>`);
    lines.push(`${indentation4}<Component />`);
    lines.push(`${indentation3}</React.StrictMode>,`);
    lines.push(`${indentation3}container || document.createElement('div')`);
    lines.push(`${indentation2});`);
    return lines;
};

const createContextBuilderGetter = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    return lines;
};

const createContextBuilderSetter = ({ typeDef }) => {
    const { name, props } = typeDef;
    const lines = [];
    return lines;
};

const createContextBuilder = ({ typeDef }) => {
    const { name } = typeDef;
    const lines = createTypeDocumentation([
        `The ${toPascalCase(name)} context builder.`,
        `Helps to build the ${toPascalCase(name)} context and manage its state.`
    ]);
    const className = createContextBuilderName(name);
    lines.push(`export class ${className} {`);

    const parts = [
        createContextBuilderPropsVariable({ typeDef }),
        createContextBuilderBuild({ typeDef }),
        createContextBuilderComponent(),
        createContextBuilderRender()
    ];

    parts.reduce((acc, currentValue, i) => {
        i > 0 && (acc = acc.concat([emptyLine]));
        acc = acc.concat(currentValue);
        return acc;
    }, [])
    .forEach(line => lines.push(line));

    lines.push('};');
    return lines;
};

const createContextBuilderFileContent = (typeDef, sourceCodeGeneratorInfo) => {
    const lines = [
        createContextBuilderHeader,
        createContextInterface,
        createComponentPropsInterface,
        createContextBuilder
    ]
    .map(x => x({ sourceCodeGeneratorInfo, typeDef }))
    .reduce((acc, currentValue) => 
        acc = acc.concat(currentValue).concat([emptyLine]), []);

    const content = lines.join(newLine);
    return content;
};

const createContextFiles = (result, sourceCodeGeneratorInfo) => {
    const { srcData } = getResultData(result);
    const { types } = srcData;

    const files = types
        .map(t => {
            const { name } = t;
            const content = createContextFileContent(t, sourceCodeGeneratorInfo);
            const file = { name: createContextFileName(name), content };
            return file;
        });

    return files;
};

const createContextBuilderFileName = (name) => `${toCamelCase(name)}ContextBuilder.tsx`;

const createContextBuilderFiles = (result, sourceCodeGeneratorInfo) => {
    const { srcData } = getResultData(result);
    const { types } = srcData;

    const files = types
        .filter(t => !t.disableContextBuilder)
        .map(t => {
            const { name } = t;
            const content = createContextBuilderFileContent(t, sourceCodeGeneratorInfo);
            const file = { name: createContextBuilderFileName(name), content };
            return file;
        });

    return files;
};

const createSourceCodes = (result, sourceCodeGeneratorInfo) => 
    new Promise((resolve, reject) => { 
        try {
            const contextFiles = createContextFiles(result, sourceCodeGeneratorInfo);
            const contextBuilderFiles = createContextBuilderFiles(result, sourceCodeGeneratorInfo);
            const utilsFiles = contextBuilderFiles.length > 0 ? [contextBuilderUtilFile] : [];
            const files = contextFiles.concat(contextBuilderFiles).concat(utilsFiles);
            resolve(createOkResult({ files }));
        } catch (err) {
            reject(createErrorResult({ errors: [err] }));
        }
});

module.exports = {
    createSourceCodes
};